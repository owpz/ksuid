import { KSUID } from "./ksuid";
import { Buffer } from "buffer";

/**
 * Sequence is a KSUID generator which produces a sequence of ordered KSUIDs
 * from a seed.
 *
 * Up to 65536 KSUIDs can be generated for a single seed.
 *
 * A typical usage of a Sequence looks like this:
 *
 * ```typescript
 * const seq = new Sequence({ seed: KSUID.random() });
 * const id = seq.next();
 * ```
 *
 * Sequence values are not safe to use concurrently from multiple threads.
 */
export class Sequence {
  private seed: KSUID;
  private count = 0;

  constructor(options: { seed: KSUID }) {
    this.seed = options.seed;
  }

  /**
   * Next produces the next KSUID in the sequence, or returns null if the
   * sequence has been exhausted.
   */
  next(): KSUID | null {
    if (this.count > 0xffff) {
      return null;
    }

    // Copy the seed
    const seedBuffer = Buffer.from(this.seed.toBuffer());

    // Apply the sequence number to the last 2 bytes
    const result = this.withSequenceNumber(seedBuffer, this.count);
    this.count++;

    return KSUID.fromBytes(result);
  }

  /**
   * Bounds returns the inclusive min and max bounds of the KSUIDs that may be
   * generated by the sequence. If all ids have been generated already then the
   * returned min value is equal to the max.
   */
  bounds(): { min: KSUID; max: KSUID } {
    let count = this.count;
    if (count > 0xffff) {
      count = 0xffff;
    }

    const seedBuffer = this.seed.toBuffer();

    const min = KSUID.fromBytes(
      this.withSequenceNumber(Buffer.from(seedBuffer), count)
    );
    const max = KSUID.fromBytes(
      this.withSequenceNumber(Buffer.from(seedBuffer), 0xffff)
    );

    return { min, max };
  }

  /**
   * Reset the sequence count back to 0, allowing the sequence to be reused.
   */
  reset(): void {
    this.count = 0;
  }

  /**
   * Returns the current count of generated KSUIDs.
   */
  getCount(): number {
    return this.count;
  }

  /**
   * Returns true if the sequence has been exhausted (count > 65535).
   */
  isExhausted(): boolean {
    return this.count > 0xffff;
  }

  /**
   * Applies a 16-bit sequence number to the last 2 bytes of the KSUID buffer.
   * This matches the Go implementation: binary.BigEndian.PutUint16(id[len(id)-2:], n)
   */
  private withSequenceNumber(buffer: Buffer, n: number): Buffer {
    // Write the 16-bit sequence number in big-endian format to the last 2 bytes
    buffer.writeUInt16BE(n, buffer.length - 2);
    return buffer;
  }
}
